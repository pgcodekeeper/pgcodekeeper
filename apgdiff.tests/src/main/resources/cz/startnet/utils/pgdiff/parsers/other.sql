CREATE ACCESS METHOD gist2 TYPE INDEX HANDLER gisthandler;
DROP ACCESS METHOD gist2;
CREATE LANGUAGE alt_lang1 HANDLER plpgsql_call_handler;
ALTER LANGUAGE alt_lang1 RENAME TO alt_lang2;
ALTER LANGUAGE alt_lang3 OWNER TO user3;
CREATE FOREIGN DATA WRAPPER alt_fdw1;
ALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw2;
CREATE SERVER alt_fserv1 FOREIGN DATA WRAPPER alt_fdw1;
ALTER SERVER alt_fserv1 RENAME TO alt_fserv2;
CREATE STATISTICS alt_stat1 ON a, b FROM alt_regress_1;
ALTER STATISTICS alt_stat1 RENAME TO alt_stat2;
ALTER STATISTICS alt_stat2 OWNER TO regress_alter_generic_user2;
ALTER STATISTICS alt_stat2 SET SCHEMA alt_nsp2;
CREATE TEXT SEARCH DICTIONARY alt_ts_dict1 (template=simple);
ALTER TEXT SEARCH DICTIONARY alt_ts_dict1 RENAME TO alt_ts_dict2;
ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 OWNER TO user3;
ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 SET SCHEMA s;
CREATE TEXT SEARCH CONFIGURATION alt_ts_conf1 (copy=english);
ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 SET SCHEMA alt_nsp2;
ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 RENAME TO alt_ts_conf4;
CREATE TEXT SEARCH TEMPLATE alt_ts_temp2 (lexize=dsimple_lexize);
ALTER TEXT SEARCH TEMPLATE alt_ts_temp1 RENAME TO alt_ts_temp2;
ALTER TEXT SEARCH TEMPLATE alt_ts_temp2 SET SCHEMA alt_nsp2;
CREATE TEXT SEARCH PARSER alt_ts_prs1 (start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
ALTER TEXT SEARCH PARSER alt_ts_prs1 RENAME TO alt_ts_prs3;
ALTER TEXT SEARCH PARSER alt_ts_prs2 SET SCHEMA alt_nsp2;
DROP FOREIGN DATA WRAPPER alt_fdw3 CASCADE;
DROP LANGUAGE alt_lang3 CASCADE;
DROP USER regress_alter_generic_user3;
NOTIFY notify_async2;
LISTEN notify_async2;
UNLISTEN notify_async2;
UNLISTEN *;
explain (verbose, costs off, analyze on, timing off, summary off) create table t1 as select 1;
EXPLAIN (COSTS OFF) SELECT * FROM t1;
ANALYZE onek2;
PREPARE p1(int) AS SELECT * FROM t1 WHERE a <= $1;
EXPLAIN (COSTS OFF) EXECUTE p1(2);
SHOW session_preload_libraries;
SHOW ALL;
SHOW TIME ZONE;
SHOW TRANSACTION ISOLATION LEVEL;
SHOW SESSION AUTHORIZATION;
LOCK TABLE lock_tbl1 IN ACCESS SHARE MODE;
LOCK lock_tbl1 IN ROW SHARE MODE;
LOCK lock_tbl1 IN SHARE ROW EXCLUSIVE MODE;
LOCK TABLE lock_tbl1 IN ROW EXCLUSIVE MODE;
LOCK TABLE lock_tbl1 IN SHARE UPDATE EXCLUSIVE MODE;
LOCK TABLE lock_tbl1 IN SHARE MODE;
LOCK TABLE lock_tbl1 IN EXCLUSIVE MODE;
LOCK TABLE lock_tbl1 IN ACCESS EXCLUSIVE MODE;
LOCK TABLE lock_tbl1 IN ACCESS SHARE MODE NOWAIT;
LOCK TABLE lock_tbl1 IN ROW SHARE MODE NOWAIT;
LOCK TABLE lock_tbl1 IN ROW EXCLUSIVE MODE NOWAIT;
LOCK TABLE lock_tbl1 IN SHARE UPDATE EXCLUSIVE MODE NOWAIT;
LOCK TABLE lock_tbl1 IN SHARE MODE NOWAIT;
LOCK TABLE lock_tbl1 IN SHARE ROW EXCLUSIVE MODE NOWAIT;
LOCK TABLE lock_tbl1 IN EXCLUSIVE MODE NOWAIT;
LOCK TABLE lock_tbl1 IN ACCESS EXCLUSIVE MODE NOWAIT;
LOCK TABLE lock_view7 IN EXCLUSIVE MODE;
LOCK TABLE lock_tbl1 * IN ACCESS EXCLUSIVE MODE;
LOCK TABLE ONLY lock_tbl1;
SAVEPOINT s1;
ROLLBACK TO s1;
DECLARE c CURSOR FOR SELECT ctid,cmin,* FROM combocidtest;
VACUUM ANALYZE vacparted(a,b,a);
ANALYZE vacparted(a,b,b);
VACUUM;
vacuum btree_tall_tbl;
VACUUM FULL vactst;
VACUUM (FULL) vacparted;
VACUUM (FULL, FREEZE) vactst;
VACUUM (ANALYZE, FULL) vactst;
VACUUM FULL vactst;
VACUUM (DISABLE_PAGE_SKIPPING) vaccluster;
VACUUM (FREEZE) does_not_exist, vaccluster;
VACUUM FULL vactst, vacparted (a, b), vaccluster (i);
TRUNCATE TABLE ndistinct;
DROP STATISTICS ab1_a_b_stats;
CREATE STATISTICS regress_schema_2.ab1_a_b_stats ON a, b FROM ab1;
DROP STATISTICS regress_schema_2.ab1_a_b_stats;
CREATE STATISTICS ab1_b_a_stats ON b, a FROM ab1;
CREATE STATISTICS func_deps_stat (dependencies) ON a, b, c FROM functional_dependencies;
RELEASE SAVEPOINT p1;
SHOW track_counts;
DISCARD SEQUENCES;
START TRANSACTION READ ONLY;
SECURITY LABEL ON TABLE seclabel_tbl1 IS 'classified';          -- fail
SECURITY LABEL FOR 'dummy' ON TABLE seclabel_tbl1 IS 'classified';      -- fail
SECURITY LABEL ON TABLE seclabel_tbl1 IS '...invalid label...';     -- fail
SECURITY LABEL ON TABLE seclabel_tbl3 IS 'unclassified';            -- fail
SECURITY LABEL ON ROLE regress_seclabel_user1 IS 'classified';          -- fail
SECURITY LABEL FOR 'dummy' ON ROLE regress_seclabel_user1 IS 'classified';      -- fail
SECURITY LABEL ON ROLE regress_seclabel_user1 IS '...invalid label...';     -- fail
SECURITY LABEL ON ROLE regress_seclabel_user3 IS 'unclassified';            -- fail
PREPARE p1 AS SELECT * FROM my_property_normal WHERE f_leak(passwd);
EXECUTE p2;
begin isolation level repeatable read;
deallocate tenk1_count;
EXECUTE pp;
DECLARE xc CURSOR WITH HOLD FOR SELECT * FROM testxmlschema.test1 ORDER BY 1, 2;
MOVE BACKWARD ALL IN xc;
begin;
abort;
end;
rollback;
savepoint s;
release savepoint s;
rollback to savepoint s;
discard temp;
discard all;
DECLARE hsc CURSOR FOR select * from hs3;
CLOSE hsc;
CHECKPOINT;
discard all;
REASSIGN OWNED BY SESSION_USER TO CURRENT_USER;
REFRESH MATERIALIZED VIEW public.mv1 WITH DATA;
COPY (SELECT 1) TO STDOUT;
EXPLAIN SELECT 1;
DISCARD ALL;
CLUSTER public.t1;
DEALLOCATE ALL;
REINDEX TABLE public.t1;
VACUUM FULL FREEZE VERBOSE ANALYZE vaccluster;
VACUUM (FULL 1, FREEZE 0, VERBOSE true, ANALYZE false, DISABLE_PAGE_SKIPPING on, SKIP_LOCKED off, INDEX_CLEANUP true, TRUNCATE off) vaccluster;
ANALYZE VERBOSE q.t1 (c1, c2), public.t2 (c1, c2);
ANALYZE (VERBOSE TRUE, SKIP_LOCKED 1) public.t1 (c1, c2), public.t2 (c1, c2);
CREATE EXTENSION hstore SCHEMA public FROM unpackaged;
TRUNCATE truncate_a;
TRUNCATE TABLE trunc_c,trunc_d,trunc_e,truncate_a,trunc_b;  -- ok
TRUNCATE TABLE truncate_a RESTRICT; -- fail
TRUNCATE TABLE truncate_a CASCADE;  -- ok
TRUNCATE ONLY trunc_fb, trunc_fa;
TRUNCATE truncate_b RESTART IDENTITY;
/* a /* b /* c */ d /* e */ f */ g /* h */ i */ -- nested comments